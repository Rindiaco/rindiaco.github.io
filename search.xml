<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[xposed 使用笔记]]></title>
    <url>%2F2019%2F06%2F03%2Fxposedusernote%2F</url>
    <content type="text"><![CDATA[Hook 的方法参数是自定义的数组123456789Class Msg&#123; &#125;Class Test&#123; public void test(Msg[] msgs)&#123; ... &#125;&#125; 首先通过classloader 反射 找到class 再通过Array构造出数组类，然后获取数组的class 123 Class MsgClass = classloader.find(.....); Class MsgArrayClass = Array.newInstance(MsgClass,0).getClass();// MsgArrayClass 就是我们要找的Class了 ## 软件消息的获取一般都在数据库方法instert里面## 修改Xposed不用重启的使用方式原理：在data/app 中有apk的备份文件，通过反射调用apk备份文件中函数，这个函数改成 xposed 劫持的方法即可,由于xposed原理，重新修改之后需要关掉宿主程序才能生效。通过这个方式，对性能会有一点影响，所以建议只是在改的时候使用，正式使用时改成原来的方式即可 12345678910111213141516171819202122232425262728293031323334353637 // pkg 具体函数所在的包名，Classname具体函数所在的类名，HandleHookMethod具体函数名称public static void invokeHandleHookMethod(String pkg, String ClassName, String HandleHookMethodName, XC_LoadPackage.LoadPackageParam packageParam)&#123; String fileDir1 = &quot;data/app/&quot;+pkg+&quot;-1/base.apk&quot;; String fileDir2 = &quot;data/app/&quot;+pkg+&quot;-2/base.apk&quot;; File pkgFile; File pkgFile1 = new File(fileDir1); File pkgFile2 = new File(fileDir2); if (pkgFile1.exists())&#123; pkgFile = pkgFile1; &#125;else if (pkgFile2.exists())&#123; pkgFile = pkgFile2; &#125;else &#123; return; &#125; PathClassLoader pathClassLoader = new PathClassLoader(pkgFile.getAbsolutePath(),ClassLoader.getSystemClassLoader()); try &#123; Class&lt;?&gt; cls = Class.forName(ClassName,true,pathClassLoader); Object instence = cls.newInstance(); Method method = cls.getDeclaredMethod(HandleHookMethodName,XC_LoadPackage.LoadPackageParam.class); method.invoke(instence,packageParam); &#125;catch (Exception e)&#123; YunkRBridge.log(e); &#125; &#125; &lt;!--调用--&gt; @Override public void handleLoadPackage(final XC_LoadPackage.LoadPackageParam lpparam) throws Throwable &#123; invokeHandleHookMethod(&quot;com.test.test&quot;, &quot;com.test.test.Test&quot;, &quot;test&quot;,lpparam); &#125; # 加固 app 获取 dex文件 和 hookhook所有加固的app直接解压出来的都是几个没啥用的class，但是无论app怎么加固在真实的App运行的时候必须会有入口，通过这个入口即可获取真实的classloader，我们劫持application的 attach方法，获取app的真实context通过context获取真实classloader 1234567891011121314151617181920/** * 加固破解方法 * @param packageParam */ public void action(final XC_LoadPackage.LoadPackageParam packageParam)&#123; String packagename = &quot;&quot;;//app的包名 if (!packagename.contains(packageParam.packageName)) return; XposedHelpers.findAndHookMethod(Application.class, &quot;attach&quot;, Context.class,new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); Context context = (Context) param.args[0]; ClassLoader classLoader = context.getClassLoader(); action2(classLoader); &#125; &#125;); &#125; 获取classloader之后就可以获取app的真实dex文件，通过class获取class.getDex方法获取dex文件。getDex是隐藏方法只能通过反射获取，在获取dex文件中可能会加载许多app以外的dex文件因此可以适当过滤 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class GetClassLoaderHook &#123; Class Dex; Method Dex_getBytes; Method getDex; String packagename; public void action(XC_LoadPackage.LoadPackageParam loadPackageParam)&#123; packagename = &quot;com.mittrachina.mit&quot;; if (!loadPackageParam.packageName.equals(packagename)) return; initRefect(); String str = &quot;java.lang.ClassLoader&quot;; String str2 = &quot;loadClass&quot;; YunkRHelpers.findAndHookMethod(str, loadPackageParam.classLoader, str2, String.class, Boolean.TYPE, new IR_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); Class cls = (Class) param.getResult(); if (cls == null)&#123; return; &#125; String name = cls.getName(); byte[] bArr = (byte[])Dex_getBytes.invoke(getDex.invoke(cls, new Object[0]), new Object[0]); // 通过dex的getDex方法获取dex文件 if (bArr == null)&#123; YunkRBridge.log(&quot;数据为空：返回&quot;); return; &#125; String dex_path = &quot;/sdcard/&quot; + packagename + &quot;/&quot; + packagename + &quot;_&quot; + bArr.length + &quot;.dex&quot;; File file = new File(dex_path); if (file.exists()) return; writeByte(bArr, file.getAbsolutePath()); &#125; &#125;); &#125; public void initRefect() &#123; try &#123; Dex = Class.forName(&quot;com.android.dex.Dex&quot;); Dex_getBytes = Dex.getDeclaredMethod(&quot;getBytes&quot;, new Class[0]); getDex = Class.forName(&quot;java.lang.Class&quot;).getDeclaredMethod(&quot;getDex&quot;, new Class[0]);//获取getDex方法 &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; &#125; public void writeByte(byte[] bArr, String str) &#123; try &#123; OutputStream outputStream = new FileOutputStream(str); outputStream.write(bArr); outputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); YunkRBridge.log(&quot;文件写出失败&quot;); &#125; &#125;&#125; ## hook 参数是 interface 的方法 直接把interface当做一个类即可]]></content>
      <tags>
        <tag>xposed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[websocket 使用笔记]]></title>
    <url>%2F2019%2F06%2F01%2Fwebsocket%2F</url>
    <content type="text"><![CDATA[WebSocket 流程12345678910graph LR连接--&gt;连接成功连接--&gt;超时处理连接--&gt;连接失败重连连接--&gt;心跳连接成功--&gt;发送消息发送消息--&gt;超时处理发送消息--&gt;失败重发连接成功--&gt;接收消息连接成功--&gt;可有可无_登录 WebSocket 实现具体协议的实现由 websocketclient实现，我们只是使用它 1implementation &apos;com.neovisionaries:nv-websocket-client:2.2&apos; 连接12345678910111213private static final int FRAME_QUEUE_SIZE = 5;private static final int CONNECT_TIMEOUT = 5000;private WebSocket webSocket;private void init()&#123; try&#123; String configUrl = &quot;ws://xxx.xxx.xxx.xxx:xxxx&quot;; webSocket = new WebSocketFactory().createSocket(url,CONNECT_TIMEOUT)//访问链接和超时大小 .setFrameQueueSize(FRAME_QUEUE_SIZE)//消息存留队列限制 .setMissingCloseFrameAllowed(false)//是否允许丢失消息 .addListener(mListener = new WsListener())//添加消息传送监听器 .connectAsynchronously();//异步连接开始&#125;&#125; 重新连接使用handler 的定时任务来实现不断的重新连接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private Handler mHandler = new Handler();private int reconnectCount = 0;//已尝试次数private long minInterval = 3000; //最短时间间隔private static final int MAXRECONNESTCOUNT = 3;//最大尝试次数private long maxInterval = 60000; //最长时间间隔private void cancleReconnect()&#123; reconnectCount = 0 ; mHandler.removeCallbacks(mReconncetTask);&#125; private void reconnect()&#123; if (!isNetConnect())&#123; //判断网络是否联通 reconnectCount = 0; Log.d(TAG,&quot;网络错误&quot;); return; &#125; //TODO 用户是否登录 if (webSocket==null || !webSocket.isOpen() || getStatus()== WsStatus.CONNECT_SUCCESS)&#123; return; &#125; reconnectCount ++; setStatus(WsStatus.CONNCETING);//设置连接状态 cancleHeartbeat();//取消心跳 long reconnectTime = minInterval; if (reconnectCount &gt; MAXRECONNESTCOUNT)&#123; url = DEF_URL; // 这里可以在多次尝试未成功之后，使用其他的连接方式例如http连接 long temp = minInterval * (reconnectCount - 2); reconnectTime = temp &gt; maxInterval ? maxInterval : temp; &#125; Log.d(TAG,&quot;准备开始第&quot;+reconnectCount+&quot;次重连,重连间隔&quot;+reconnectTime+&quot;-- url : &quot;+url); mHandler.postDelayed(mReconncetTask,reconnectTime);&#125;//重新连接任务private Runnable mReconncetTask = new Runnable() &#123; @Override public void run() &#123; try &#123; webSocket = new WebSocketFactory().createSocket(url,CONNECT_TIMEOUT) .setFrameQueueSize(FRAME_QUEUE_SIZE) .setMissingCloseFrameAllowed(false) .addListener(mListener = new WsListener()) .connectAsynchronously(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125;; 消息响应,接收消息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//监听器需要 继承webSocketAdapter 然后再设置给WebSocketclass WsListener extends WebSocketAdapter&#123; @Override public void onTextMessage(WebSocket websocket, String text) throws Exception &#123; super.onTextMessage(websocket, text); Log.d(TAG,&quot;收到信息:&quot;+text); Response response = Codec.decode(text); if (response.getRespEvent() == NetCodeUtil.RECIVER_CALLBACK)&#123; CallbackWrapper wrapper = callbackWrapperMap.remove(Long.parseLong(response.getSeqId())); if (wrapper == null)&#123; Log.d(TAG,&quot;没有找到对应的回调&quot;); return; &#125; try &#123; wrapper.getTimoutTask().cancel(true); ChildResponse childResponse = Codec.decodeChildResp(response.getResp()); if (childResponse.isOK())&#123; Object o = new Gson().fromJson(childResponse.getData(), wrapper.getAction().getRespClazz()); wrapper.getTempCallback().onSuccess(o); &#125;else &#123; wrapper.getTempCallback() .onError(ErrorCode.BUSINIESS_EXCEPTION.getMsg(), wrapper.getRequest()); &#125; &#125;catch (JsonSyntaxException e)&#123; e.printStackTrace(); wrapper.getTempCallback() .onError(ErrorCode.PARSE_ECEPTION.getMsg(), wrapper.getRequest()); &#125; &#125;else if (response.getRespEvent() == NetCodeUtil.SERVER_NOTICE)&#123;// 消息通知 NotifyListenerManager.getInstence().fire(response); &#125;else if (response.getRespEvent() == NetCodeUtil.CHAT)&#123; String resp = response.getResp(); if (TextUtils.isEmpty(resp)) &#123; Log.d(TAG,&quot;消息为空&quot;); return; &#125; Message message = Codec.decodeResp(resp); if (onReciveMessage!=null)&#123; onReciveMessage.onMessage(message); &#125; &#125; &#125; @Override public void onBinaryMessage(WebSocket websocket, byte[] binary) throws Exception &#123; super.onBinaryMessage(websocket, binary); &#125; @Override public void onConnected(WebSocket websocket, Map&lt;String, List&lt;String&gt;&gt; headers) throws Exception &#123; super.onConnected(websocket, headers); Log.d(TAG,&quot;连接成功&quot;); setStatus(WsStatus.CONNECT_SUCCESS); cancleReconnect(); doAuth(); &#125; @Override public void onConnectError(WebSocket websocket, WebSocketException exception) throws Exception &#123; super.onConnectError(websocket, exception); Log.d(TAG,&quot;连接错误:&quot;); setStatus(WsStatus.CONNCET_FAIL); reconnect(); &#125; @Override public void onDisconnected(WebSocket websocket, WebSocketFrame serverCloseFrame, WebSocketFrame clientCloseFrame, boolean closedByServer) throws Exception &#123; super.onDisconnected(websocket, serverCloseFrame, clientCloseFrame, closedByServer); Log.d(TAG,&quot;连接断开&quot;); setStatus(WsStatus.CONNCET_FAIL); reconnect(); &#125; &#125; 发送消息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private static final int REQUEST_TIMEOUT = 10000;private AtomicLong seqId = new AtomicLong(SystemClock.uptimeMillis());public void sendReq(Action action, Object req, String cid, ICallback callback)&#123; sendReq(action,req,cid,callback,REQUEST_TIMEOUT);&#125;public void sendReq(Action action, Object req, String cid, ICallback callback, int timeout)&#123; sendReq(action,req,cid,callback,timeout,1);&#125;@SuppressWarnings(&quot;unchecked&quot;)private &lt;T&gt; void sendReq(Action action, final T req, String cid, final ICallback callback, final long timeout, int reqCount)&#123; if (!isNetConnect())&#123; callback.onFail(&quot;网络不可用&quot;); return; &#125; Request request = new Request.Builder&lt;T&gt;() .action(action.getAction()) .reqEvent(action.getReqEvent()) .seqId(seqId.getAndIncrement()) .reCount(reqCount) .req(req) .cid(cid) .build(); //回调消息的发送结果 IWsCallback temp = new IWsCallback() &#123; @Override public void onSuccess(Object o) &#123; sendHandler.obtainMessage(SUCCESS_HANDLE,new CallbackDataWrapper(callback,o)) .sendToTarget(); &#125; @Override public void onError(String msg, Request request) &#123; sendHandler.obtainMessage(ERROR_HANDLE,new CallbackDataWrapper(callback,msg)) .sendToTarget(); &#125; @Override public void onTimeout(Request request, Action action) &#123; timeoutHandle(request,action,callback,timeout); &#125; &#125;; ScheduledFuture timoutTask = enqueueTimout(request.getSeqId(),timeout); callbackWrapperMap.put(request.getSeqId(), new CallbackWrapper(temp,timoutTask,action,request)); //发送消息 webSocket.sendText(new Gson().toJson(request));&#125; 心跳保活连接保活的原理就是不停的向服务器发送一个空的消息保证连接的连通 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private static final long HEARTBEAT_INTERVAL = 30000;private int heartbeatFailCount = 0;private void doAuth()&#123; sendReq(Action.LOGIN, null, null,new ICallback() &#123; @Override public void onSucess(Object o) &#123; setStatus(WsStatus.AUTH_SUCCESS); startHeartbeat(); delaySyncData(); &#125; @Override public void onFail(String msg) &#123; &#125; &#125;);&#125;private void startHeartbeat()&#123; mHandler.postDelayed(heartbeatTask,HEARTBEAT_INTERVAL);&#125;private void cancleHeartbeat()&#123; heartbeatFailCount= 0; mHandler.removeCallbacks(heartbeatTask);&#125;private Runnable heartbeatTask = new Runnable() &#123; @Override public void run() &#123; sendReq(Action.HEARTBEAT, null, null,new ICallback() &#123; @Override public void onSucess(Object o) &#123; heartbeatFailCount = 0; &#125; @Override public void onFail(String msg) &#123; heartbeatFailCount ++; if (heartbeatFailCount &gt;= 3)&#123; reconnect(); &#125; &#125; &#125;); mHandler.postDelayed(this,HEARTBEAT_INTERVAL); &#125;&#125;; 超时处理123456789101112131415161718192021222324252627282930313233343536373839404142434445private final int SUCCESS_HANDLE = 0x01;private final int ERROR_HANDLE = 0x02;private Handler sendHandler = new Handler(Looper.getMainLooper())&#123; @Override public void handleMessage(android.os.Message msg) &#123; switch (msg.what)&#123; case SUCCESS_HANDLE : CallbackDataWrapper sucessWrapper = (CallbackDataWrapper) msg.obj; sucessWrapper.getCallback().onSucess(sucessWrapper.getData()); break; case ERROR_HANDLE: CallbackDataWrapper errorWrapper = (CallbackDataWrapper) msg.obj; errorWrapper.getCallback().onFail(errorWrapper.getData().toString()); break; &#125; &#125;&#125;;private void timeoutHandle(Request request,Action action,ICallback callback,long timout)&#123; if (request.getReqCount() &gt; 3)&#123; Log.d(TAG,&quot;超过3次连接超时&quot;); //TODO 走http请求 &#125;else &#123; sendReq(action,request.getReq(),null,callback,timout,request.getReqCount()); request.setReqCount(request.getReqCount() + 1); Log.d(TAG,&quot;第&quot;+request.getReqCount()+&quot;次发起&quot;+action.getAction()); &#125;&#125;private ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();private Map&lt;Long,CallbackWrapper&gt; callbackWrapperMap = new HashMap&lt;&gt;();private ScheduledFuture enqueueTimout(final long seqId, long timeout)&#123; return executorService.schedule(new Runnable() &#123; @Override public void run() &#123; CallbackWrapper wrapper = callbackWrapperMap.remove(seqId); if (wrapper != null)&#123; wrapper.getTempCallback().onTimeout(wrapper.getRequest(),wrapper.getAction()); &#125; &#125; &#125;,timeout,TimeUnit.MILLISECONDS);&#125; 其他包装类回调包装类 1234567891011121314151617181920212223242526272829public class CallbackWrapper &#123; private final IWsCallback tempCallback; private final ScheduledFuture timoutTask; private final Action action; private final Request request; public CallbackWrapper(IWsCallback tempCallback, ScheduledFuture timoutTask, Action action, Request request) &#123; this.tempCallback = tempCallback; this.timoutTask = timoutTask; this.action = action; this.request = request; &#125; public IWsCallback getTempCallback() &#123; return tempCallback; &#125; public ScheduledFuture getTimoutTask() &#123; return timoutTask; &#125; public Action getAction() &#123; return action; &#125; public Request getRequest() &#123; return request; &#125;&#125; 回调数据包装类 12345678910111213141516171819202122232425public class CallbackDataWrapper&lt;T&gt; &#123; private ICallback&lt;T&gt; callback; private Object data; public CallbackDataWrapper(ICallback&lt;T&gt; callback, Object data) &#123; this.callback = callback; this.data = data; &#125; public ICallback&lt;T&gt; getCallback() &#123; return callback; &#125; public void setCallback(ICallback&lt;T&gt; callback) &#123; this.callback = callback; &#125; public Object getData() &#123; return data; &#125; public void setData(Object data) &#123; this.data = data; &#125;&#125; 回调通知类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class NotifyListenerManager &#123; private final String TAG = this.getClass().getName(); private volatile static NotifyListenerManager manager; private Map&lt;String,INotifyListener&gt; map = new HashMap&lt;&gt;(); private NotifyListenerManager()&#123; regist(); &#125; public static NotifyListenerManager getInstence()&#123; if (manager == null)&#123; synchronized (NotifyListenerManager.class)&#123; if (manager == null)&#123; manager = new NotifyListenerManager(); &#125; &#125; &#125; return manager; &#125; private void regist()&#123; map.put(&quot;notifyAnnounceMsg&quot;, new AnnounceMsgListener()); &#125; public void fire(Response response)&#123; String action = response.getAction(); String resp = response.getResp(); INotifyListener listener = map.get(action); if (listener!=null)&#123; return; &#125; NotifyClass notifyClass = listener.getClass().getAnnotation(NotifyClass.class); Class&lt;?&gt; clazz = notifyClass.value(); Object result = null; try &#123; result = new Gson().fromJson(resp,clazz); &#125;catch (JsonSyntaxException e)&#123; e.printStackTrace(); &#125; listener.fire(result); &#125; public interface INotifyListener&lt;T&gt;&#123; void fire(T t); &#125; /** * 自定义一个注解 注解的作用是返回 class 对象 * 写这个的原因是实现一个观察者模式 */ @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface NotifyClass&#123; Class&lt;?&gt; value(); &#125; @NotifyClass(AnnounceMsgNotify.class) public class AnnounceMsgListener implements INotifyListener&lt;AnnounceMsgListener&gt;&#123; @Override public void fire(AnnounceMsgListener announceMsgListener) &#123;// 在此处处理事务 &#125; &#125; public class AnnounceMsgNotify&#123; @SerializedName(&quot;msg_version&quot;) private String msgVersion; public String getMsgVersion() &#123; return msgVersion; &#125; public void setMsgVersion(String msgVersion) &#123; this.msgVersion = msgVersion; &#125; &#125;&#125; 其余的request ，response ，childResponse不重要可以自己商定这里只写代码的大概]]></content>
      <tags>
        <tag>webSocket android</tag>
      </tags>
  </entry>
</search>
